/**
 * Forensic Investigation Report Generator
 * ========================================
 * Generates court-admissible, chain-of-custody compliant,
 * cryptographically verifiable digital evidence reports.
 *
 * Standards: Digital forensic best practices, legal admissibility,
 * chain of custody protocols.
 */

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

// ─── Types ─────────────────────────────────────────────────────────────────────

export interface ReportEvidence {
    id: string;
    file_name: string;
    file_type: string;
    file_size: number | string;
    client_sha256: string;
    server_sha256: string;
    hash_match: boolean;
    upload_timestamp: string;
    uploaded_by: string;
    device_info?: string;
    integrity_status: 'VERIFIED' | 'COMPROMISED' | 'PENDING';
}

export interface ReportAuditEntry {
    action: string;
    performed_by: string;
    timestamp: string;
    event_id: string;
    integrity_status: string;
    details?: string;
}

export interface ReportAIAnalysis {
    risk_score: number;
    severity: string;
    findings: string[];
    observations: string[];
    recommendations: string[];
}

export interface ForensicReportData {
    case_id: string;
    case_title: string;
    case_description: string;
    case_status: string;
    case_created_at: string;
    user_id: string;
    user_email: string;
    evidence: ReportEvidence[];
    audit_log: ReportAuditEntry[];
    ai_analysis?: ReportAIAnalysis | null;
    investigator_notes?: string;
    report_version?: number;
}

export interface GeneratedReport {
    report_id: string;
    report_hash: string;
    generated_at: string;
    content_txt: string;
    version: number;
}

// ─── Utilities ─────────────────────────────────────────────────────────────────

function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

function utcNow(): string {
    return new Date().toISOString();
}

function formatUTC(iso: string): string {
    try {
        return new Date(iso).toISOString();
    } catch {
        return iso;
    }
}

function formatBytes(bytes: number | string): string {
    const b = typeof bytes === 'string' ? parseFloat(bytes) : bytes;
    if (isNaN(b) || b === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(b) / Math.log(k));
    return parseFloat((b / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Compute SHA-256 hash of a string using Web Crypto API
 */
export async function sha256(content: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

// ─── TXT Report Generation ────────────────────────────────────────────────────

const SEPARATOR = '═'.repeat(80);
const THIN_SEP = '─'.repeat(80);
const SYSTEM_NAME = 'Evidence Vault';
const SYSTEM_VERSION = '1.0.0';

export async function generateForensicReportTXT(data: ForensicReportData): Promise<GeneratedReport> {
    const reportId = generateUUID();
    const generatedAt = utcNow();
    const version = data.report_version || 1;

    // Build report content (hash placeholder first, replaced after hashing)
    let content = buildTXTContent(data, reportId, generatedAt, version, '<PENDING_HASH>');
    // Compute SHA-256 of the content (without the hash itself)
    const reportHash = await sha256(content);
    // Replace placeholder with actual hash
    content = content.replace('<PENDING_HASH>', reportHash);

    return {
        report_id: reportId,
        report_hash: reportHash,
        generated_at: generatedAt,
        content_txt: content,
        version,
    };
}

function buildTXTContent(
    data: ForensicReportData,
    reportId: string,
    generatedAt: string,
    version: number,
    reportHash: string
): string {
    const lines: string[] = [];
    const push = (...args: string[]) => args.forEach((l) => lines.push(l));
    const blank = () => lines.push('');

    // ── 1. Cover Page ──
    push(SEPARATOR);
    push('           FORENSIC INVESTIGATION REPORT');
    push('           Digital Evidence Preservation System');
    push(SEPARATOR);
    blank();
    push(`  Case ID:             ${data.case_id}`);
    push(`  Case Title:          ${data.case_title}`);
    push(`  Report ID:           ${reportId}`);
    push(`  Report Version:      v${version}`);
    push(`  Generated (UTC):     ${generatedAt}`);
    push(`  Generated By:        ${data.user_email} (${data.user_id})`);
    push(`  System:              ${SYSTEM_NAME} v${SYSTEM_VERSION}`);
    push(`  Report SHA-256:      ${reportHash}`);
    blank();
    push(SEPARATOR);
    blank();

    // ── 2. Executive Summary ──
    push('SECTION 1: EXECUTIVE SUMMARY');
    push(THIN_SEP);
    blank();
    push(`  Case Title:          ${data.case_title}`);
    push(`  Case Status:         ${data.case_status.toUpperCase()}`);
    push(`  Date Created (UTC):  ${formatUTC(data.case_created_at)}`);
    push(`  Total Evidence:      ${data.evidence.length} file(s)`);
    blank();
    push('  Case Overview:');
    push(`    ${data.case_description || 'No description provided.'}`);
    blank();
    push('  Nature of Evidence:');
    if (data.evidence.length > 0) {
        const types = [...new Set(data.evidence.map((e) => e.file_type.toUpperCase()))];
        push(`    File types: ${types.join(', ')}`);
        push(`    Total files: ${data.evidence.length}`);
        const verified = data.evidence.filter((e) => e.integrity_status === 'VERIFIED').length;
        push(`    Verified: ${verified} / ${data.evidence.length}`);
    } else {
        push('    No evidence files associated with this case.');
    }
    blank();
    push('  Purpose of Preservation:');
    push('    Digital evidence has been preserved for potential legal proceedings,');
    push('    investigative review, or cybercrime reporting. Cryptographic hash');
    push('    verification ensures tamper-proof integrity of all stored files.');
    blank();

    // ── 3. Evidence Inventory ──
    push('SECTION 2: EVIDENCE INVENTORY');
    push(THIN_SEP);
    blank();
    if (data.evidence.length > 0) {
        data.evidence.forEach((ev, idx) => {
            push(`  [Evidence #${idx + 1}]`);
            push(`    Evidence ID:         ${ev.id}`);
            push(`    File Name:           ${ev.file_name}`);
            push(`    File Type (MIME):    ${ev.file_type}`);
            push(`    File Size:           ${formatBytes(ev.file_size)}`);
            push(`    Client SHA-256:      ${ev.client_sha256 || 'N/A'}`);
            push(`    Server SHA-256:      ${ev.server_sha256 || 'N/A'}`);
            push(`    Hash Match Status:   ${ev.hash_match ? 'VERIFIED' : ev.client_sha256 && ev.server_sha256 ? 'FAILED' : 'PENDING'}`);
            push(`    Upload Time (UTC):   ${formatUTC(ev.upload_timestamp)}`);
            push(`    Uploaded By:         ${ev.uploaded_by}`);
            push(`    Device Information:  ${ev.device_info || 'Not recorded'}`);
            push(`    Integrity Status:    ${ev.integrity_status}`);
            blank();
        });
    } else {
        push('  No evidence files to report.');
        blank();
    }

    // ── 4. Chain of Custody Log ──
    push('SECTION 3: CHAIN OF CUSTODY LOG');
    push(THIN_SEP);
    blank();
    push('  Date (UTC)                 | Action           | Performed By     | Evidence ID       | Status');
    push('  ' + '─'.repeat(76));
    if (data.audit_log.length > 0) {
        data.audit_log.forEach((entry) => {
            const date = formatUTC(entry.timestamp).padEnd(25);
            const action = (entry.action || '').toUpperCase().padEnd(17);
            const by = (entry.performed_by || 'SYSTEM').substring(0, 16).padEnd(17);
            const evId = (entry.event_id || '-').substring(0, 18).padEnd(18);
            const status = entry.integrity_status || '-';
            push(`  ${date}| ${action}| ${by}| ${evId}| ${status}`);
        });
    } else {
        push('  No audit log entries available.');
    }
    blank();

    // ── 5. Integrity Verification Statement ──
    push('SECTION 4: INTEGRITY VERIFICATION STATEMENT');
    push(THIN_SEP);
    blank();
    push('  FORMAL DECLARATION:');
    blank();
    push('  "The cryptographic hash values confirm that the evidence has not been');
    push('  altered since the time of submission. All timestamps are recorded in');
    push('  Coordinated Universal Time (UTC) and generated by the system."');
    blank();
    push('  Verification Method:    SHA-256 Cryptographic Hashing');
    push('  Hash Algorithm:         SHA-2 (256-bit)');
    push('  Timestamp Authority:    System UTC Clock');
    push('  Immutability:           Original hash values cannot be overwritten');
    blank();

    // ── 6. AI Analysis Section ──
    if (data.ai_analysis) {
        push('SECTION 5: AI THREAT ANALYSIS');
        push(THIN_SEP);
        blank();
        const ai = data.ai_analysis;
        push(`  Risk Classification:   ${ai.severity || 'N/A'}`);
        push(`  Severity Score:        ${ai.risk_score}/10`);
        blank();
        if (ai.findings && ai.findings.length > 0) {
            push('  Findings:');
            ai.findings.forEach((f, i) => push(`    ${i + 1}. ${f}`));
            blank();
        }
        if (ai.observations && ai.observations.length > 0) {
            push('  Technical Observations:');
            ai.observations.forEach((o, i) => push(`    ${i + 1}. ${o}`));
            blank();
        }
        if (ai.recommendations && ai.recommendations.length > 0) {
            push('  Recommendations:');
            ai.recommendations.forEach((r, i) => push(`    ${i + 1}. ${r}`));
            blank();
        }
    }

    // ── 7. Investigation Notes ──
    push('SECTION 6: INVESTIGATION NOTES');
    push(THIN_SEP);
    blank();
    if (data.investigator_notes) {
        push(`  ${data.investigator_notes}`);
    } else {
        push('  No investigator remarks have been entered for this case.');
    }
    blank();

    // ── 8. Legal Declaration ──
    push('SECTION 7: LEGAL DECLARATION');
    push(THIN_SEP);
    blank();
    push('  This report was automatically generated by the Evidence Vault system.');
    push('  The following conditions are formally declared:');
    blank();
    push('    1. This report was automatically generated by a secure digital');
    push('       evidence preservation system without manual alteration.');
    blank();
    push('    2. SHA-256 cryptographic hash verification was performed on all');
    push('       evidence files at the time of upload and preservation.');
    blank();
    push('    3. A complete chain of custody has been maintained. All access,');
    push('       modification, and export events are recorded with UTC timestamps.');
    blank();
    push('    4. The system prevents modification of stored integrity fields.');
    push('       Original hash values and timestamps are immutable once recorded.');
    blank();
    push('  DISCLAIMER: This report preserves cryptographic integrity but does not');
    push('  replace certified forensic investigation by qualified professionals.');
    push('  This document is suitable for use as supporting evidence in legal');
    push('  proceedings, subject to proper authentication and foundation requirements.');
    blank();

    // ── 9. Appendix ──
    push('SECTION 8: APPENDIX');
    push(THIN_SEP);
    blank();
    push('  A. Raw JSON Metadata');
    push('  ' + '─'.repeat(40));
    const rawJson = {
        case_id: data.case_id,
        case_title: data.case_title,
        case_status: data.case_status,
        created_at: data.case_created_at,
        evidence_count: data.evidence.length,
        evidence_ids: data.evidence.map((e) => e.id),
    };
    push('  ' + JSON.stringify(rawJson, null, 2).split('\n').join('\n  '));
    blank();
    push('  B. Full Hash Values');
    push('  ' + '─'.repeat(40));
    data.evidence.forEach((ev) => {
        push(`  ${ev.file_name}:`);
        push(`    Client: ${ev.client_sha256 || 'N/A'}`);
        push(`    Server: ${ev.server_sha256 || 'N/A'}`);
    });
    blank();
    push('  C. System Configuration Snapshot');
    push('  ' + '─'.repeat(40));
    push(`  System:          ${SYSTEM_NAME}`);
    push(`  Version:         ${SYSTEM_VERSION}`);
    push(`  Hash Algorithm:  SHA-256 (Web Crypto API)`);
    push(`  Timestamp:       ${generatedAt}`);
    push(`  Environment:     Browser Client`);
    push(`  User Agent:      ${typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A'}`);
    blank();

    // ── Verification & QR Instructions ──
    push(SEPARATOR);
    push('  REPORT VERIFICATION');
    push(SEPARATOR);
    blank();
    push(`  Report SHA-256:  ${reportHash}`);
    blank();
    push('  To verify the integrity of this report:');
    push('    1. Save this file without modification.');
    push('    2. Recompute the SHA-256 hash of this file.');
    push('    3. Compare the computed hash with the Report SHA-256 above.');
    push('    4. If the hashes match, the report has not been altered.');
    blank();
    push(`  QR Code Data:   Case=${data.case_id} | Hash=${reportHash}`);
    blank();
    push(SEPARATOR);
    push(`  Case ID: ${data.case_id} | Report ID: ${reportId} | Generated: ${generatedAt}`);
    push(SEPARATOR);

    return lines.join('\n');
}

// ─── PDF Report Generation ─────────────────────────────────────────────────────

export async function generateForensicReportPDF(
    data: ForensicReportData,
    existingReport?: GeneratedReport
): Promise<{ blob: Blob; report: GeneratedReport }> {
    // Generate the TXT report first (for hash reference)
    const report = existingReport || (await generateForensicReportTXT(data));

    const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 15;
    const contentWidth = pageWidth - margin * 2;
    let y = margin;

    const addFooter = () => {
        const pageCount = doc.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
            doc.setPage(i);
            doc.setFontSize(7);
            doc.setTextColor(120);
            doc.text(
                `Case ID: ${data.case_id} | Report ID: ${report.report_id} | Generated: ${report.generated_at}`,
                margin,
                pageHeight - 5
            );
            doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 5, { align: 'right' });
        }
    };

    const checkPage = (needed: number) => {
        if (y + needed > pageHeight - 20) {
            doc.addPage();
            y = margin;
        }
    };

    const addSectionTitle = (title: string) => {
        checkPage(15);
        doc.setFontSize(13);
        doc.setTextColor(16, 185, 129); // emerald
        doc.setFont('helvetica', 'bold');
        doc.text(title, margin, y);
        y += 4;
        doc.setDrawColor(16, 185, 129);
        doc.setLineWidth(0.5);
        doc.line(margin, y, margin + contentWidth, y);
        y += 8;
        doc.setTextColor(40);
        doc.setFont('helvetica', 'normal');
    };

    const addField = (label: string, value: string) => {
        checkPage(8);
        doc.setFontSize(8);
        doc.setTextColor(100);
        doc.setFont('helvetica', 'bold');
        doc.text(label, margin + 4, y);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(40);
        doc.text(value, margin + 52, y);
        y += 5;
    };

    const addParagraph = (text: string, fontSize = 9) => {
        doc.setFontSize(fontSize);
        doc.setTextColor(60);
        const splitText = doc.splitTextToSize(text, contentWidth - 8);
        checkPage(splitText.length * 4 + 4);
        doc.text(splitText, margin + 4, y);
        y += splitText.length * 4 + 4;
    };

    // ── Cover Page ──
    // Background header band
    doc.setFillColor(24, 24, 27); // zinc-950
    doc.rect(0, 0, pageWidth, 70, 'F');

    doc.setFontSize(22);
    doc.setTextColor(16, 185, 129);
    doc.setFont('helvetica', 'bold');
    doc.text('FORENSIC INVESTIGATION REPORT', pageWidth / 2, 25, { align: 'center' });

    doc.setFontSize(10);
    doc.setTextColor(161, 161, 170); // zinc-400
    doc.setFont('helvetica', 'normal');
    doc.text('Digital Evidence Preservation System', pageWidth / 2, 33, { align: 'center' });

    doc.setFontSize(8);
    doc.text(`${SYSTEM_NAME} v${SYSTEM_VERSION}`, pageWidth / 2, 40, { align: 'center' });

    // Cover fields
    y = 50;
    doc.setFontSize(8);
    doc.setTextColor(200);
    const coverFields = [
        ['Case ID', data.case_id],
        ['Report ID', report.report_id],
        ['Version', `v${report.version}`],
        ['Generated', report.generated_at],
    ];
    coverFields.forEach(([label, value]) => {
        doc.setFont('helvetica', 'bold');
        doc.text(`${label}:`, margin + 10, y);
        doc.setFont('helvetica', 'normal');
        doc.text(value, margin + 42, y);
        y += 5;
    });

    y = 80;

    // ── Section 1: Executive Summary ──
    addSectionTitle('1. EXECUTIVE SUMMARY');
    addField('Case Title:', data.case_title);
    addField('Case Status:', data.case_status.toUpperCase());
    addField('Date Created:', formatUTC(data.case_created_at));
    addField('Evidence Files:', `${data.evidence.length} file(s)`);
    y += 2;
    addParagraph(data.case_description || 'No description provided.');

    // ── Section 2: Evidence Inventory ──
    addSectionTitle('2. EVIDENCE INVENTORY');
    if (data.evidence.length > 0) {
        const tableBody = data.evidence.map((ev, i) => [
            `#${i + 1}`,
            ev.file_name.length > 20 ? ev.file_name.substring(0, 18) + '...' : ev.file_name,
            ev.file_type,
            formatBytes(ev.file_size),
            (ev.client_sha256 || 'N/A').substring(0, 12) + '...',
            ev.integrity_status,
            formatUTC(ev.upload_timestamp).split('T')[0],
        ]);

        autoTable(doc, {
            startY: y,
            margin: { left: margin, right: margin },
            head: [['#', 'File Name', 'Type', 'Size', 'Hash (partial)', 'Status', 'Date']],
            body: tableBody,
            theme: 'grid',
            headStyles: { fillColor: [24, 24, 27], textColor: [16, 185, 129], fontSize: 7, fontStyle: 'bold' },
            bodyStyles: { fontSize: 7, textColor: [60, 60, 60] },
            alternateRowStyles: { fillColor: [245, 245, 245] },
            styles: { cellPadding: 2 },
        });

        y = (doc as any).lastAutoTable.finalY + 8;

        // Detailed evidence entries
        data.evidence.forEach((ev, i) => {
            checkPage(50);
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(40);
            doc.text(`Evidence #${i + 1}: ${ev.file_name}`, margin + 4, y);
            y += 6;
            doc.setFont('helvetica', 'normal');
            addField('Evidence ID:', ev.id);
            addField('Client SHA-256:', ev.client_sha256 || 'N/A');
            addField('Server SHA-256:', ev.server_sha256 || 'N/A');
            addField('Hash Match:', ev.hash_match ? 'VERIFIED ✓' : 'FAILED ✗');
            addField('Uploaded By:', ev.uploaded_by);
            addField('Device Info:', ev.device_info || 'Not recorded');
            y += 4;
        });
    } else {
        addParagraph('No evidence files associated with this case.');
    }

    // ── Section 3: Chain of Custody ──
    addSectionTitle('3. CHAIN OF CUSTODY LOG');
    if (data.audit_log.length > 0) {
        const custodyBody = data.audit_log.map((entry) => [
            formatUTC(entry.timestamp).replace('T', '\n').replace('Z', ''),
            entry.action.toUpperCase(),
            entry.performed_by || 'SYSTEM',
            entry.event_id?.substring(0, 12) || '-',
            entry.integrity_status || '-',
        ]);

        autoTable(doc, {
            startY: y,
            margin: { left: margin, right: margin },
            head: [['Date (UTC)', 'Action', 'Performed By', 'Event ID', 'Status']],
            body: custodyBody,
            theme: 'grid',
            headStyles: { fillColor: [24, 24, 27], textColor: [16, 185, 129], fontSize: 7, fontStyle: 'bold' },
            bodyStyles: { fontSize: 7, textColor: [60, 60, 60] },
            alternateRowStyles: { fillColor: [245, 245, 245] },
            styles: { cellPadding: 2 },
        });

        y = (doc as any).lastAutoTable.finalY + 8;
    } else {
        addParagraph('No audit log entries available.');
    }

    // ── Section 4: Integrity Verification Statement ──
    addSectionTitle('4. INTEGRITY VERIFICATION STATEMENT');
    addParagraph(
        'FORMAL DECLARATION: "The cryptographic hash values confirm that the evidence has not been altered since the time of submission. All timestamps are recorded in Coordinated Universal Time (UTC) and generated by the system."'
    );
    addField('Verification Method:', 'SHA-256 Cryptographic Hashing');
    addField('Hash Algorithm:', 'SHA-2 (256-bit)');
    addField('Timestamp Authority:', 'System UTC Clock');
    addField('Immutability:', 'Original hash values cannot be overwritten');

    // ── Section 5: AI Analysis (optional) ──
    if (data.ai_analysis) {
        addSectionTitle('5. AI THREAT ANALYSIS');
        const ai = data.ai_analysis;
        addField('Risk Classification:', ai.severity || 'N/A');
        addField('Severity Score:', `${ai.risk_score}/10`);
        if (ai.findings?.length) {
            y += 2;
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.text('Findings:', margin + 4, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            ai.findings.forEach((f, i) => addParagraph(`${i + 1}. ${f}`, 8));
        }
        if (ai.recommendations?.length) {
            doc.setFont('helvetica', 'bold');
            doc.text('Recommendations:', margin + 4, y);
            y += 5;
            doc.setFont('helvetica', 'normal');
            ai.recommendations.forEach((r, i) => addParagraph(`${i + 1}. ${r}`, 8));
        }
    }

    // ── Section 6: Investigation Notes ──
    addSectionTitle('6. INVESTIGATION NOTES');
    addParagraph(data.investigator_notes || 'No investigator remarks have been entered for this case.');

    // ── Section 7: Legal Declaration ──
    addSectionTitle('7. LEGAL DECLARATION');
    addParagraph(
        'This report was automatically generated by the Evidence Vault system. The following conditions are formally declared:'
    );
    const declarations = [
        'This report was automatically generated by a secure digital evidence preservation system without manual alteration.',
        'SHA-256 cryptographic hash verification was performed on all evidence files at the time of upload and preservation.',
        'A complete chain of custody has been maintained. All access, modification, and export events are recorded with UTC timestamps.',
        'The system prevents modification of stored integrity fields. Original hash values and timestamps are immutable once recorded.',
    ];
    declarations.forEach((d, i) => addParagraph(`${i + 1}. ${d}`, 8));
    y += 2;
    addParagraph(
        'DISCLAIMER: This report preserves cryptographic integrity but does not replace certified forensic investigation by qualified professionals.'
    );

    // ── Section 8: Verification ──
    addSectionTitle('8. REPORT VERIFICATION');
    addField('Report SHA-256:', report.report_hash);
    y += 2;
    addParagraph(
        'To verify the integrity of this report, recompute the SHA-256 hash of the corresponding TXT report file and compare with the Report SHA-256 displayed above. Matching hashes confirm the report has not been altered.'
    );
    addParagraph(`QR Code Data: Case=${data.case_id} | Hash=${report.report_hash}`);

    // Add footers
    addFooter();

    const blob = doc.output('blob');
    return { blob, report };
}

// ─── ZIP Package Export ─────────────────────────────────────────────────────────

export async function generateReportZIPPackage(
    data: ForensicReportData
): Promise<{ blob: Blob; report: GeneratedReport }> {
    const txtReport = await generateForensicReportTXT(data);
    const { blob: pdfBlob } = await generateForensicReportPDF(data, txtReport);

    // Build SHA256SUMS content
    let sha256sums = `${txtReport.report_hash}  forensic_report_${data.case_id}.txt\n`;

    // Build metadata JSON
    const metadataJson = JSON.stringify(
        {
            report_id: txtReport.report_id,
            case_id: data.case_id,
            case_title: data.case_title,
            generated_at: txtReport.generated_at,
            report_hash: txtReport.report_hash,
            version: txtReport.version,
            evidence_count: data.evidence.length,
            evidence: data.evidence.map((e) => ({
                id: e.id,
                file_name: e.file_name,
                client_sha256: e.client_sha256,
                server_sha256: e.server_sha256,
                integrity_status: e.integrity_status,
            })),
            system: { name: SYSTEM_NAME, version: SYSTEM_VERSION },
        },
        null,
        2
    );

    // Since we cannot use archiver in the browser, we'll create individual downloads
    // Return the TXT report and let the UI handle offering both downloads
    return { blob: pdfBlob, report: txtReport };
}

// ─── Download Helpers ──────────────────────────────────────────────────────────

export function downloadBlob(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

export function downloadText(content: string, filename: string) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    downloadBlob(blob, filename);
}
